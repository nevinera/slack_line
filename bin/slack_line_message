#!/usr/bin/env ruby

require_relative "../lib/slack_line"
require "optparse"
require "reline"

options = {
  post_to: nil,
  append: nil,
  update: nil,
  message_number: nil,
  save: nil,
  content: nil,
  dsl: nil
}

configuration = SlackLine::Configuration.new(SlackLine.configuration)

OptionParser.new do |opts|
  opts.banner = "Usage: build_slack_line_message [options] [content]"

  opts.on("-t", "--slack-token TOKEN", "Slack API token") { |t| configuration.slack_token = t }
  opts.on("-u", "--look-up-users", "Enable user look-up") { configuration.look_up_users = true }
  opts.on("-n", "--bot-name NAME", "Bot name to use") { |n| configuration.bot_name = n }
  opts.on("-p", "--post-to TARGET", "Channel or user post the message to") { |t| options[:post_to] = t }
  opts.on("-a", "--append PATH", "Append to the thread of a persisted message or thread") { |p| options[:append] = p }
  opts.on("-U", "--update PATH", "Replace the content of a persisted message or thread message") { |p| options[:update] = p }
  opts.on("-m", "--message-number N", Integer, "Which message in a thread to update (1-based)") { |n| options[:message_number] = n }
  opts.on("-s", "--save PATH", "Save the result as JSON to PATH") { |p| options[:save] = p }
end.parse!

abort "--append and --update cannot be used together" if options[:append] && options[:update]
abort "--message-number requires --update" if options[:message_number] && !options[:update]

if ARGV.empty?
  warn "No content provided, reading (as dsl) from stdin. Control+D to finish:\n\n"
  options[:dsl] = ""
  while (line = Reline.readline("MSG> ", true))
    options[:dsl] += line + "\n"
  end
else
  options[:content] = ARGV.dup
end

client = SlackLine::Client.new(configuration)

if options[:append]
  loaded = SlackLine.from_json(JSON.parse(File.read(options[:append])), client:)
  message = options[:content] ? SlackLine::Message.new(*options[:content], client:) : SlackLine::Message.new(client:) { eval(options[:dsl]) }
  sent_thread =
    case loaded
    when SlackLine::SentMessage then loaded.thread_from(message)
    when SlackLine::SentThread then loaded.append(message)
    end
  warn "Appended to thread in #{sent_thread.channel}"
  File.write(options[:save], JSON.pretty_generate(sent_thread.as_json)) if options[:save]
elsif options[:update]
  loaded = SlackLine.from_json(JSON.parse(File.read(options[:update])), client:)
  sent =
    case loaded
    when SlackLine::SentMessage
      abort "--message-number cannot be used when updating a single message" if options[:message_number]
      options[:content] ? loaded.update(*options[:content]) : loaded.update { eval(options[:dsl]) }
    when SlackLine::SentThread
      abort "--message-number is required when updating a thread" unless options[:message_number]
      idx = options[:message_number] - 1
      abort "--message-number #{options[:message_number]} is out of range (thread has #{loaded.size} messages)" unless (0...loaded.size).cover?(idx)
      updated = options[:content] ? loaded.sent_messages[idx].update(*options[:content]) : loaded.sent_messages[idx].update { eval(options[:dsl]) }
      SlackLine::SentThread.new(*loaded.sent_messages[0...idx], updated, *loaded.sent_messages[(idx + 1)..])
    end
  warn "Updated message in #{sent.channel}"
  File.write(options[:save], JSON.pretty_generate(sent.as_json)) if options[:save]
elsif options[:post_to]
  message = options[:content] ? SlackLine::Message.new(*options[:content], client:) : SlackLine::Message.new(client:) { eval(options[:dsl]) }
  sent = message.post(to: options[:post_to])
  warn "Posted message to #{options[:post_to]}"
  File.write(options[:save], JSON.pretty_generate(sent.as_json)) if options[:save]
else
  message = options[:content] ? SlackLine::Message.new(*options[:content], client:) : SlackLine::Message.new(client:) { eval(options[:dsl]) }
  warn "Preview message at #{message.builder_url}\n\n"
  puts JSON.pretty_generate(message.content.as_json)
end
