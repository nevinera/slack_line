#!/usr/bin/env ruby
# frozen_string_literal: true

# Exercises bin/slack_line_message and bin/slack_line_thread against real Slack channels.
# Usage: bin/qa/slack_line_qa PUBLIC_CHANNEL PRIVATE_CHANNEL [MENTION_HANDLE]
# MENTION_HANDLE: a user or group handle (without @) to verify look_up_users resolution
# Requires: SLACK_LINE_SLACK_TOKEN environment variable

require "open3"
require "tmpdir"
require "json"

public_channel = ARGV[0] or abort "Usage: #{$PROGRAM_NAME} PUBLIC_CHANNEL PRIVATE_CHANNEL [MENTION_HANDLE]"
private_channel = ARGV[1] or abort "Usage: #{$PROGRAM_NAME} PUBLIC_CHANNEL PRIVATE_CHANNEL [MENTION_HANDLE]"
mention_handle = ARGV[2]
abort "SLACK_LINE_SLACK_TOKEN is required" unless ENV["SLACK_LINE_SLACK_TOKEN"]

MESSAGE_SCRIPT = File.expand_path("../slack_line_message", __dir__)
THREAD_SCRIPT = File.expand_path("../slack_line_thread", __dir__)

ScriptResult = Struct.new(:stdout, :stderr, :exit_status, keyword_init: true) do
  def success? = exit_status.zero?
  def failure? = !success?
end

def rescued
  yield
rescue
  nil
end

def run_script(script, *args, stdin: nil)
  stdout, stderr, status = Open3.capture3("ruby", script, *args, stdin_data: stdin.to_s)
  ScriptResult.new(stdout:, stderr:, exit_status: status.exitstatus)
end

@step_num = 0
@failures = []
@current_group = nil

def group(description, &block)
  puts "\n#{description}"
  @current_group = description
  block.call
ensure
  @current_group = nil
end

def step(description, &block)
  @step_num += 1
  num = @step_num
  print "  [#{num}] #{description}... "
  $stdout.flush
  block.call
  puts "passed"
rescue => e
  puts "FAILED: #{e.message}"
  @failures << {num:, group: @current_group, description:, error: e.message}
end

def assert(condition, message = "assertion failed")
  raise message unless condition
end

puts "Announcing QA run in ##{public_channel} and ##{private_channel}..."
[public_channel, private_channel].each do |channel|
  result = run_script(MESSAGE_SCRIPT, "-p", channel,
    "QA run starting — #{Time.now.strftime("%Y-%m-%d %H:%M:%S %Z")}")
  abort "Failed to post announcement to ##{channel}: #{result.stderr.strip}" unless result.success?
end

Dir.mktmpdir("slack_line_qa") do |tmpdir|
  msg2_path = File.join(tmpdir, "msg2.json")
  msg3_path = File.join(tmpdir, "msg3.json")
  thread2_path = File.join(tmpdir, "thread2.json")

  # ---- slack_line_message ----

  group "slack_line_message: simple text post to ##{public_channel} [msg 1/3]" do
    step "posts and reports channel on stderr" do
      result = run_script(MESSAGE_SCRIPT, "-p", public_channel,
        "QA msg [1/3 in ##{public_channel}]: Simple text post via positional args")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?(public_channel), "stderr did not mention channel: #{result.stderr.strip}"
    end
  end

  group "slack_line_message: post with --save, then --append a thread reply [msg 2/3 in ##{public_channel}]" do
    step "posts and saves valid message JSON to disk" do
      result = run_script(MESSAGE_SCRIPT, "-p", public_channel, "-s", msg2_path,
        "QA msg [2/3 in ##{public_channel}]: Message saved to file (thread reply expected below)")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert File.exist?(msg2_path), "--save did not create file at #{msg2_path}"
      saved = rescued { JSON.parse(File.read(msg2_path)) }
      assert saved, "saved file is not valid JSON"
      assert saved["type"] == "message", "saved JSON has wrong type: #{saved["type"].inspect}"
    end

    step "appends thread reply from saved file and reports thread on stderr" do
      result = run_script(MESSAGE_SCRIPT, "-a", msg2_path,
        "QA thread reply for msg [2/3 in ##{public_channel}] (this message should appear as a thread reply)")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.match?(/thread/i), "stderr did not mention thread: #{result.stderr.strip}"
    end
  end

  group "slack_line_message: post with --save, then --update in place [msg 3/3 in ##{public_channel}]" do
    step "posts and saves valid message JSON to disk" do
      result = run_script(MESSAGE_SCRIPT, "-p", public_channel, "-s", msg3_path,
        "QA msg [3/3 in ##{public_channel}]: Message to be updated in place (should read 'UPDATED' after this step)")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert File.exist?(msg3_path), "--save did not create file at #{msg3_path}"
    end

    step "updates saved message in place and reports update on stderr" do
      result = run_script(MESSAGE_SCRIPT, "-U", msg3_path,
        "QA msg [3/3 in ##{public_channel}]: UPDATED — message was successfully updated in place")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.match?(/[Uu]pdated/), "stderr did not confirm update: #{result.stderr.strip}"
    end
  end

  group "slack_line_message: simple text post to ##{private_channel} [msg 1/1]" do
    step "posts and reports channel on stderr" do
      result = run_script(MESSAGE_SCRIPT, "-p", private_channel,
        "QA msg [1/1 in ##{private_channel}]: Simple text post to private channel")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?(private_channel), "stderr did not mention channel: #{result.stderr.strip}"
    end
  end

  group "slack_line_message: preview mode (no --post-to)" do
    step "exits 0, writes JSON to stdout, writes builder URL to stderr" do
      result = run_script(MESSAGE_SCRIPT, "QA preview-only message — not posted")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?("block-kit-builder"), "stderr did not include builder URL: #{result.stderr.strip}"
      parsed = begin
        JSON.parse(result.stdout)
      rescue
        nil
      end
      assert parsed, "stdout was not valid JSON: #{result.stdout.strip}"
    end
  end

  group "slack_line_message: error handling" do
    step "--post-to and --append together exits nonzero with helpful error" do
      result = run_script(MESSAGE_SCRIPT, "-p", public_channel, "-a", msg2_path, "some text")
      assert result.failure?, "expected nonzero exit, got 0"
      assert result.stderr.match?(/--append|--post-to/i), "error not helpful: #{result.stderr.strip}"
    end

    step "--message-number without --update exits nonzero with helpful error" do
      result = run_script(MESSAGE_SCRIPT, "-m", "0", "-p", public_channel, "some text")
      assert result.failure?, "expected nonzero exit, got 0"
      assert result.stderr.match?(/--message-number|--update/i), "error not helpful: #{result.stderr.strip}"
    end
  end

  # ---- look_up_users ----

  mention_text = mention_handle ? "@#{mention_handle}" : "@unknown-handle-qa-test"
  resolve_note = mention_handle ? "(mention should be resolved to a Slack link)" : "(no handle provided — mention should be left as-is)"

  group "slack_line_message: look_up_users post to ##{public_channel}" do
    step "posts with -u flag and #{resolve_note}" do
      result = run_script(MESSAGE_SCRIPT, "-p", public_channel, "-u",
        "QA look_up_users [##{public_channel}]: #{mention_text} #{resolve_note}")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?(public_channel), "stderr did not mention channel: #{result.stderr.strip}"
    end
  end

  group "slack_line_message: look_up_users post to ##{private_channel}" do
    step "posts with -u flag and #{resolve_note}" do
      result = run_script(MESSAGE_SCRIPT, "-p", private_channel, "-u",
        "QA look_up_users [##{private_channel}]: #{mention_text} #{resolve_note}")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?(private_channel), "stderr did not mention channel: #{result.stderr.strip}"
    end
  end

  # ---- slack_line_thread ----

  group "slack_line_thread: simple 3-message thread post to ##{public_channel} [thread 1/2]" do
    step "posts and reports channel on stderr" do
      result = run_script(THREAD_SCRIPT,
        "-p", public_channel,
        "QA thread [1/2 in ##{public_channel}]: Simple thread — message 1 of 3 (2 replies expected below)",
        "QA thread [1/2 in ##{public_channel}]: Simple thread — message 2 of 3",
        "QA thread [1/2 in ##{public_channel}]: Simple thread — message 3 of 3")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?(public_channel), "stderr did not mention channel: #{result.stderr.strip}"
    end
  end

  group "slack_line_thread: 2-message thread post with --save to ##{public_channel} [thread 2/2]" do
    step "posts and saves valid thread JSON to disk" do
      result = run_script(THREAD_SCRIPT,
        "-p", public_channel, "-s", thread2_path,
        "QA thread [2/2 in ##{public_channel}]: Thread saved to file — message 1 of 2",
        "QA thread [2/2 in ##{public_channel}]: Thread saved to file — message 2 of 2")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert File.exist?(thread2_path), "--save did not create file at #{thread2_path}"
      saved = rescued { JSON.parse(File.read(thread2_path)) }
      assert saved, "saved file is not valid JSON"
      assert saved["type"] == "thread", "saved JSON has wrong type: #{saved["type"].inspect}"
      assert saved["messages"].size == 2, "expected 2 messages in saved thread, got #{saved["messages"].size}"
    end
  end

  group "slack_line_thread: simple 2-message thread post to ##{private_channel} [thread 1/1]" do
    step "posts and reports channel on stderr" do
      result = run_script(THREAD_SCRIPT,
        "-p", private_channel,
        "QA thread [1/1 in ##{private_channel}]: Simple thread — message 1 of 2 (1 reply expected below)",
        "QA thread [1/1 in ##{private_channel}]: Simple thread — message 2 of 2")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.include?(private_channel), "stderr did not mention channel: #{result.stderr.strip}"
    end
  end

  group "slack_line_thread: preview mode (no --post-to)" do
    step "exits 0, writes per-message JSON blocks to stdout, writes builder URLs to stderr" do
      result = run_script(THREAD_SCRIPT,
        "QA preview-only thread — message 1 of 2 — not posted",
        "QA preview-only thread — message 2 of 2 — not posted")
      assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
      assert result.stderr.scan("block-kit-builder").size >= 2,
        "expected at least 2 builder URLs in stderr: #{result.stderr.strip}"
      assert result.stdout.scan('"type": "section"').size >= 2,
        "expected at least 2 section blocks in stdout: #{result.stdout.strip}"
    end
  end
end

puts "\n#{@step_num} steps run."
if @failures.empty?
  puts "All passed."
else
  puts "#{@failures.size} failure(s):"
  @failures.each do |f|
    label = f[:group] ? "#{f[:group]} / #{f[:description]}" : f[:description]
    puts "  [#{f[:num]}] #{label}: #{f[:error]}"
  end
  exit 1
end
