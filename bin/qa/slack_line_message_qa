#!/usr/bin/env ruby
# frozen_string_literal: true

# Exercises bin/slack_line_message against real Slack channels.
# Usage: bin/qa/slack_line_message_qa PUBLIC_CHANNEL PRIVATE_CHANNEL
# Requires: SLACK_LINE_SLACK_TOKEN environment variable

require "open3"
require "tmpdir"
require "json"

public_channel = ARGV[0] or abort "Usage: #{$PROGRAM_NAME} PUBLIC_CHANNEL PRIVATE_CHANNEL"
private_channel = ARGV[1] or abort "Usage: #{$PROGRAM_NAME} PUBLIC_CHANNEL PRIVATE_CHANNEL"
abort "SLACK_LINE_SLACK_TOKEN is required" unless ENV["SLACK_LINE_SLACK_TOKEN"]

SCRIPT = File.expand_path("../slack_line_message", __dir__)
TOKEN_ARGS = ["-t", ENV.fetch("SLACK_LINE_SLACK_TOKEN")]

ScriptResult = Struct.new(:stdout, :stderr, :exit_status, keyword_init: true) do
  def success? = exit_status.zero?
  def failure? = !success?
end

def run_script(*args, stdin: nil)
  stdout, stderr, status = Open3.capture3("ruby", SCRIPT, *args, stdin_data: stdin.to_s)
  ScriptResult.new(stdout:, stderr:, exit_status: status.exitstatus)
end

@step_num = 0
@failures = []

def step(description, &block)
  @step_num += 1
  num = @step_num
  print "[#{num}] #{description}... "
  $stdout.flush
  block.call
  puts "passed"
rescue => e
  puts "FAILED: #{e.message}"
  @failures << {num:, description:, error: e.message}
end

def assert(condition, message = "assertion failed")
  raise message unless condition
end

Dir.mktmpdir("slack_line_qa") do |tmpdir|
  msg2_path = File.join(tmpdir, "msg2.json")
  msg3_path = File.join(tmpdir, "msg3.json")

  # ---- Public channel ----

  step "post simple text to ##{public_channel} [1/3]" do
    result = run_script(*TOKEN_ARGS, "-p", public_channel,
      "QA [1/3 in ##{public_channel}]: Simple text post via positional args")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert result.stderr.include?(public_channel), "stderr did not mention channel: #{result.stderr.strip}"
  end

  step "post to ##{public_channel} [2/3] with --save" do
    result = run_script(*TOKEN_ARGS, "-p", public_channel, "-s", msg2_path,
      "QA [2/3 in ##{public_channel}]: Message saved to file (thread reply expected below)")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert File.exist?(msg2_path), "--save did not create file at #{msg2_path}"
    saved = JSON.parse(File.read(msg2_path)) rescue nil
    assert saved, "saved file is not valid JSON"
    assert saved["type"] == "message", "saved JSON has wrong type: #{saved["type"].inspect}"
  end

  step "append thread reply to [2/3] via --append" do
    result = run_script(*TOKEN_ARGS, "-a", msg2_path,
      "QA thread reply for [2/3 in ##{public_channel}] (this message should appear as a thread reply)")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert result.stderr.match?(/thread/i), "stderr did not mention thread: #{result.stderr.strip}"
  end

  step "post to ##{public_channel} [3/3] with --save" do
    result = run_script(*TOKEN_ARGS, "-p", public_channel, "-s", msg3_path,
      "QA [3/3 in ##{public_channel}]: Message to be updated in place (should read 'UPDATED' after this step)")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert File.exist?(msg3_path), "--save did not create file at #{msg3_path}"
  end

  step "update [3/3] in place via --update" do
    result = run_script(*TOKEN_ARGS, "-U", msg3_path,
      "QA [3/3 in ##{public_channel}]: UPDATED — message was successfully updated in place")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert result.stderr.match?(/[Uu]pdated/), "stderr did not confirm update: #{result.stderr.strip}"
  end

  # ---- Private channel ----

  step "post simple text to ##{private_channel} [1/1]" do
    result = run_script(*TOKEN_ARGS, "-p", private_channel,
      "QA [1/1 in ##{private_channel}]: Simple text post to private channel")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert result.stderr.include?(private_channel), "stderr did not mention channel: #{result.stderr.strip}"
  end

  # ---- Non-posting ----

  step "preview mode exits 0 with JSON on stdout and builder URL on stderr" do
    result = run_script(*TOKEN_ARGS, "QA preview-only message — not posted")
    assert result.success?, "exit #{result.exit_status} — #{result.stderr.strip}"
    assert result.stderr.include?("block-kit-builder"), "stderr did not include builder URL: #{result.stderr.strip}"
    parsed = begin
      JSON.parse(result.stdout)
    rescue
      nil
    end
    assert parsed, "stdout was not valid JSON: #{result.stdout.strip}"
  end

  step "--post-to and --append together exits nonzero with helpful error" do
    result = run_script(*TOKEN_ARGS, "-p", public_channel, "-a", msg2_path, "some text")
    assert result.failure?, "expected nonzero exit, got 0"
    assert result.stderr.match?(/--append|--post-to/i), "error not helpful: #{result.stderr.strip}"
  end

  step "--message-number without --update exits nonzero with helpful error" do
    result = run_script(*TOKEN_ARGS, "-m", "0", "-p", public_channel, "some text")
    assert result.failure?, "expected nonzero exit, got 0"
    assert result.stderr.match?(/--message-number|--update/i), "error not helpful: #{result.stderr.strip}"
  end
end

puts "\n#{@step_num} steps run."
if @failures.empty?
  puts "All passed."
else
  puts "#{@failures.size} failure(s):"
  @failures.each { |f| puts "  [#{f[:num]}] #{f[:description]}: #{f[:error]}" }
  exit 1
end
