#!/usr/bin/env ruby

require_relative "../lib/slack_line"
require "optparse"
require "reline"

options = {
  post_to: nil,
  content: nil,
  dsl: nil
}

configuration = SlackLine::Configuration.new(SlackLine.configuration)

OptionParser.new do |opts|
  opts.banner = "Usage: build_slack_line_message [options] [content]"

  opts.on("-t", "--slack-token TOKEN", "Slack API token") { |t| configuration.slack_token = t }
  opts.on("-u", "--look-up-users", "Enable user look-up") { configuration.look_up_users = true }
  opts.on("-n", "--bot-name NAME", "Bot name to use") { |n| configuration.bot_name = n }
  opts.on("-p", "--post-to TARGET", "Channel or user post the message to") { |t| options[:post_to] = t }
end.parse!

if ARGV.empty?
  warn "No content provided, reading (as dsl) from stdin. Control+D to finish:\n\n"
  options[:dsl] = ""
  while (line = Reline.readline("THD> ", true))
    options[:dsl] += line + "\n"
  end
else
  options[:content] = ARGV.dup
end

client = SlackLine::Client.new(configuration)

thread =
  if options[:content]
    SlackLine::Thread.new(*options[:content], client:)
  else
    SlackLine::Thread.new(client:) { eval(options[:dsl]) }
  end

if options[:post_to]
  thread.post_to(options[:post_to])
  warn "Posted thread to #{options[:post_to]}"
else
  warn "Preview messages at:"
  thread.builder_urls.each { |url| warn "  #{url}" }

  thread.each do |message|
    puts "\n\n--------------------- Message ---------------------\n"
    puts "Preview at: #{message.builder_url}\n\n"
    puts JSON.pretty_generate(message.content.as_json)
  end
end
